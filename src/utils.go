package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

func ensureNil(v any) {
	if v != nil {
		log.Panicf("expected nil value: %v", v)
	}
}

func ensureNotNil(v any) {
	if v == nil {
		log.Panic("unexpected nil value")
	}
}

func reverse(s []Dumper) {
	for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	}
}

// Make filepath to map to parent directories READMEs
func elem(path string) Element {
	var (
		isdir   bool
		refs    []Dumper
		d, p, s string
	)

	if strings.HasSuffix(path, "/") {
		isdir = true
	}
	//fmt.Println(path, isdir)
	path = filepath.Clean(path)
	d, _ = filepath.Split(path)
	for d != "" {
		d = filepath.Clean(d)
		d, p = filepath.Split(d)
		if isdir {
			s += "../"
		}
		isdir = true
		p = filepath.Clean(p)
		refs = append(refs, newText(" / "), newRef(p, s+"README.md"))
	}
	reverse(refs)
	refs = append(refs, newText(filepath.Base(path)))
	return newElement(refs...)
}

func getDepth(path string) int {
	if path == "" || path == "." {
		return 0
	}
	path += "/"
	return strings.Count(path, "/")
}

func getRelativePath(from, to string) string {
	if strings.HasSuffix(from, "/") {
		panic("err")
	}
	from = filepath.Clean(from)
	fromDir := filepath.Dir(from)

	to = filepath.Clean(to)
	toDir := filepath.Dir(to)

	commonDir := getCommonPrefix(fromDir, toDir)
	log.Println("++++", fromDir, toDir, commonDir, getDepth(fromDir), getDepth(commonDir))
	path := []string{"."}
	for i := 0; i < getDepth(fromDir)-getDepth(commonDir); i++ {
		path = append(path, "..")
	}

	toRel := strings.TrimPrefix(toDir, commonDir)
	if toRel != "" {
		path = append(path, toRel)
	}
	path = append(path, filepath.Base(to))
	ret := filepath.Join(path...)
	ret = filepath.Clean(ret)
	log.Println("===", ret+"")
	//if to == "vsync/atomic.h" {
	//	os.Exit(0)
	//}
	return ret
}

func loadIndex() (*Index, error) {
	index, err := LoadIndex(*input)
	if err != nil {
		return nil, err
	}
	fd, err := os.Create(filepath.Join(*output, "index.md"))
	if err != nil {
		return nil, err
	}
	defer fd.Close()
	return index, index.Dump(fd)
}

// loadRegistry parses every .xml file in the input directory and registers
// their CompoundDefs.
func loadRegistry(inputDir string) (*Registry, error) {
	reg := newRegistry(inputDir)
	files, err := ioutil.ReadDir(inputDir)
	if err != nil {
		return nil, err
	}

	// Load every single file generated by doxygen.
	// We assume a flat hierarchy inm the given directory.
	for _, file := range files {
		if file.IsDir() || !strings.Contains(file.Name(), ".xml") {
			log.Println("Ignoring", file.Name())
			continue
		}

		// The index.xml is ignored for now.
		if file.Name() == "index.xml" {
			continue
		}

		// We load each file, which is simply a slice of CompoundDefs.
		log.Println("Parsing", file.Name())
		fn := filepath.Join(inputDir, file.Name())
		file, err := loadFile(fn)
		if err != nil {
			return nil, err
		}

		// We now register the CompoundDefs.
		for _, c := range file.CompoundDef {
			if shouldIgnore(c.Location.File) {
				continue
			}
			reg.Register(c)
		}
	}
	return reg, nil
}

type DumpContext struct {
	Desc      *os.File
	Reg       *Registry
	Path      string
	OutputDir string
	InputDir  string
}

func (reg *Registry) dumpDirs(inputDir, outputDir string) error {
	ctx := DumpContext{
		Reg: reg,
	}
	for _, c := range reg._dir {
		if shouldIgnore(c.Location.File) {
			continue
		}

		log.Println("Dump DIR =", c.Location.File)
		ctx.Path = filepath.Join(c.Location.File, "README.md")
		dir := c.Location.File
		odir := filepath.Join(*output, dir)
		ofn := filepath.Join(odir, "README.md")

		// Dump
		w := new(Writer)
		if err := c.Dump(ctx, w); err != nil {
			return err
		}
		if err := DumpFooter(ctx, w, strings.Count(dir, "/")); err != nil {
			return err
		}
		if err := w.Write(ofn); err != nil {
			return err
		}
	}
	return nil
}

// Create an output markdown file for each file in the registry.
func (reg *Registry) dumpFiles(inputDir, outputDir string) error {
	ctx := DumpContext{Reg: reg, InputDir: inputDir, OutputDir: outputDir}
	for _, c := range reg._files {
		log.Println("Processing", c.Location.File)
		ctx.Path = c.Location.File

		// The path of the generated file should match of the input file.
		fnn := fmt.Sprintf("%s.md", c.Location.File)
		fn := filepath.Join(outputDir, fnn)

		w := new(Writer)
		if err := c.Dump(ctx, w); err != nil {
			return err
		}
		if err := DumpFooter(ctx, w, strings.Count("", "/")); err != nil {
			return err
		}
		if err := w.Write(fn); err != nil {
			return err
		}
	}
	return nil
}

func (reg *Registry) dumpGroups(inputDir, outputDir string) error {
	fn := "DOC_GROUPS.md"
	ctx := DumpContext{
		Reg:  reg,
		Path: fn,
	}
	fn = filepath.Join(outputDir, fn)

	w := new(Writer)
	w.Println()
	w.Println("---")
	w.Println("# Group Index")
	w.Println()
	w.Println("| Group | Description |")
	w.Println("|--|--|")

	for _, c := range reg._groups {
		wctx := DumpContext{
			Reg:  reg,
			Path: c.Location.File,
		}
		wctx.Path = c.getPath(wctx)
		wfn := filepath.Join(outputDir, wctx.Path)
		log.Println("Processing group", c.CompoundName)
		ww := new(Writer)
		if err := c.Dump(wctx, ww); err != nil {
			return err
		}
		if err := DumpFooter(wctx, ww, 1); err != nil {
			return err
		}
		if err := ww.Write(wfn); err != nil {
			return err
		}

		pl := reg.Disable(ParaLine)
		w.Print("| ")
		newRef(c.CompoundName, c.Id).Dump(ctx, w)
		w.Print("|")
		c.Brief.Dump(ctx, w)
		w.Println("|")
		if pl {
			reg.Enable(ParaLine)
		}
	}

	if err := DumpFooter(ctx, w, 1); err != nil {
		return err
	}
	return nil //w.Write(fn)
}

func dirUp(depth int) (path string) {
	for i := 0; i < depth; i++ {
		path += "../"
	}
	return
}

func DumpFooter(ctx DumpContext, w *Writer, depth int) error {
	w.Println()
	w.Println("---")
	return nil

	// path := dirUp(depth)
	// entries := []Entry{
	// 	newEntry(newRef("Home", path+"README")),
	// 	newEntry(newRef("Modules", path+"INDEX_MODULES")),
	// 	newEntry(newRef("Files", path+"INDEX_FILES")),
	// 	newEntry(newText("Description")),
	// }
	// cols := len(entries)
	// tab := Table{
	// 	Cols: cols,
	// 	Row: []Row{
	// 		{Entry: emptyEntries(cols)},
	// 		{Entry: entries}},
	// }

	// w.Printf("_Last updated on %s._\n", time.Now().Format("2006.01.02 15:04:05"))
	// return tab.Dump(ctx, w)
}

func dumpPages(reg *Registry) error {
	/*
		ctx := DumpContext{Reg: reg}
		for _, c := range reg._page {
			log.Println("Processing page", c.CompoundName)
			var name string
			if c.CompoundName == "index" {
				name = "README.md"
			} else {
				name = fmt.Sprintf("page-%s.md", c.CompoundName)
			}
			fn := filepath.Join(*output, name)
			dir := filepath.Dir(fn)
			if err := os.MkdirAll(dir, 0775); err != nil {
				return err
			}
			fd, err := os.Create(fn)
			if err != nil {
				return err
			}
			defer fd.Close()
			if err := c.Dump(ctx, fd); err != nil {
				return err
			}
		}
	*/
	return nil
}

var (
	blackListInternal = regexp.MustCompile(`.*/internal`)
	blackListDoc      = regexp.MustCompile(`.*/doc.h$`)
)

// shouldIgnore returns true if the name is in the ignore black list.
func shouldIgnore(name string) bool {
	switch {
	case blackListDoc.MatchString(name):
	case blackListInternal.MatchString(name):
	default:
		return false
	}
	// any matching case breaks here and returns true
	return true
}
